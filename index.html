<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>CandySwap - Free To Play</title>
    <link rel="manifest" href="manifest.json">
    <link rel="icon" type="image/x-icon" href="assets/favicon.jpeg">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@600;800&family=Nunito:wght@400;700&display=swap');

        * {
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }

        body {
            margin: 0;
            padding: 0;
            background-image: url('assets/banner/1d.png');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            color: white;
            font-family: 'Nunito', sans-serif;
            height: 100dvh;
            width: 100vw;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 100%;
            max-width: 600px;
            padding: env(safe-area-inset-top, 20px) 20px 10px 20px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            z-index: 50;
            pointer-events: none;
        }

        .stats-group {
            pointer-events: none;
        }

        h1 {
            font-family: 'Cinzel', serif;
            font-size: 1.9rem;
            margin: 0;
            background: linear-gradient(to right, #7eb2ff, #ff837a);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .gold-display {
            display: inline-flex;
            font-size: 1.8rem;
            font-weight: bold;
            align-items: center;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 215, 0, 0.3);
            padding: 5px 15px;
            color: gold;
            border-radius: 20px;
            backdrop-filter: blur(5px);
        }

        .gold-display img {
            margin-right: 5px;
            filter: drop-shadow(0 0 5px rgba(255, 215, 0, 0.5));
            width: 26px;
        }

        .score-container {
            text-align: right;
            pointer-events: auto;
        }

        .score-value {
            font-size: 1.8rem;
            font-weight: bold;
            display: inline-flex;
            align-items: center;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 215, 0, 0.3);
            padding: 5px 15px;
            color: rgb(255, 255, 255);
            border-radius: 20px;
            backdrop-filter: blur(5px);
        }

        #pause-btn {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 215, 0, 0.3);
            padding: 5px 15px;
            color: rgb(211, 211, 211);
            border-radius: 20px;
            font-family: 'Cinzel', serif;
            cursor: pointer;
            font-size: 1.8rem;
            pointer-events: auto;
            margin-top: 5px;
        }

        #pause-btn:hover {
            color: gold;
        }

        #game-board {
            position: relative;
            flex-grow: 1;
            width: 100%;
            max-width: 600px;
            height: 100%;
            background-image: url('assets/bg/1.png');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            overflow: hidden;
            box-shadow: 0 0 50px rgba(0,0,0,0.5);
        }

        .block {
            position: absolute;
            background-size: 80% 80%;
            background-position: center;
            background-repeat: no-repeat;
            transition: top 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94), left 0.3s ease;
            cursor: pointer;
            background-color: #11111191;
            border: 1px solid rgb(0, 255, 128);
            z-index: 10;
        }

        .block.selected {
            filter: brightness(1.5) drop-shadow(0 0 10px rgb(255, 1, 1));
            transform: scale(1.1);
            z-index: 20;
        }

        .block.bomb {
            border: 2px solid #ff00ff;
            box-shadow: inset 0 0 15px #ff00ff, 0 0 10px #ff00ff;
            animation: pulseBomb 1s infinite alternate;
        }

        @keyframes pulseBomb {
            from { transform: scale(1); filter: brightness(1); }
            to { transform: scale(1.05); filter: brightness(1.3); }
        }

        .block.pop {
            animation: popOut 0.3s forwards ease-in;
        }

        @keyframes popOut {
            0% { transform: scale(1); opacity: 1; }
            100% { transform: scale(0); opacity: 0; }
        }

        #message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Cinzel', serif;
            font-size: clamp(2rem, 10vw, 4rem);
            color: #fff;
            text-shadow: 0 0 20px #ff00ff;
            pointer-events: none;
            opacity: 0;
            z-index: 100;
            text-align: center;
            width: 100%;
        }

        #message.animate {
            animation: msgPop 1s forwards;
        }

        @keyframes msgPop {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            20% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
            80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1.5); }
        }

        #pause-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgb(27, 27, 27);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
            background-image: url('assets/banner/1d.png');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }

        #pause-overlay.show {
            display: flex;
        }

        .menu-title {
            font-family: 'Cinzel', serif;
            font-size: 2.5rem;
            margin-bottom: 30px;
            color: #7afcff;
        }

        .menu-btn {
            background: linear-gradient(135deg, #ff61f2, #460491);
            border: none;
            color: white;
            padding: 15px 40px;
            font-size: 1.2rem;
            font-family: 'Cinzel', serif;
            border-radius: 50px;
            cursor: pointer;
            margin: 10px;
            width: 200px;
            box-shadow: 0 4px 15px rgba(255, 58, 91, 0.4);
        }

        .menu-btn.secondary {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div class="stats-group">
            <img style="width:120px;" src="assets/titleimg.png" alt="CandySwap"><br>
        </div>
        <div class="score-container">
            <button id="pause-btn">PAUSE</button>
            <div class="score-value" id="score">0</div>
            <div class="gold-display">
                <img src="assets/coin.png" alt="" onerror="this.src='https://img.icons8.com/color/48/coin.png'">
                <span style="font-size:26px;" id="gold">0</span>
            </div>
        </div>
    </div>

    <div id="game-board"></div>
    <div id="message">COMBO!</div>

    <div id="pause-overlay">
        <div class="menu-title">PAUSED</div>
        <button class="menu-btn" id="resume-btn">RESUME</button>
        <a href="shop.html"><button class="menu-btn">SHOP</button></a>
        <button class="menu-btn secondary" id="restart-btn">CLAIM</button>
        <a href="settings.html"><button class="menu-btn">SETTINGS</button></a>
    </div>

    <script src="sound.js"></script>
    <script src="mainmenu.js"></script>

    <script>
        /** * Theme & Block Logic **/
        let blockTypes = [
            { id: 'KitKat', img: 'assets/candy/kit-kat.png' },
            { id: 'Hershey', img: 'assets/candy/hershey.png' },
            { id: 'ReeceCup', img: 'assets/candy/reece-cup.png' },
            { id: 'm&m', img: 'assets/candy/m&m.png' },
            { id: 'Cookie', img: 'assets/candy/cookie.png' },
            { id: 'Butterscoch', img: 'assets/candy/butterscoch.png' }
        ];

        const BOMB_TYPE = { id: 'Bomb', img: 'assets/candy/bomb.png', isBomb: true };

        async function loadIslandTheme() {
            const activeIsland = localStorage.getItem('candySwap_activeIsland');
            if (!activeIsland || activeIsland === 'default') return;

            return new Promise((resolve) => {
                const script = document.createElement('script');
                script.src = `islands/${activeIsland}.js`;
                script.onload = () => {
                    if (window.IslandTheme) {
                        blockTypes = window.IslandTheme.blocks;
                        if (window.IslandTheme.backgroundGradient) {
                            document.body.style.background = window.IslandTheme.backgroundGradient;
                        }
                        if (window.IslandTheme.bombImage) {
                            BOMB_TYPE.img = window.IslandTheme.bombImage;
                        }
                        if (window.IslandTheme.boardImage) {
                            boardEl.style.backgroundImage = `url(${window.IslandTheme.boardImage})`;
                        }
                        if (window.IslandTheme.music && typeof bgm !== 'undefined') {
                            bgm.src = window.IslandTheme.music;
                        }
                    }
                    resolve();
                };
                script.onerror = () => {
                    console.error("Failed to load island theme:", activeIsland);
                    resolve();
                };
                document.head.appendChild(script);
            });
        }

        /** * Game Engine **/
        let rows = 8, cols = 8;
        let board = [];
        let isAnimating = false;
        let isPaused = false;
        let score = 0;
        let gold = parseInt(localStorage.getItem('candySwap_gold')) || 0;
        let bombActive = false; 
        
        let cellSize = 0, offsetX = 0, offsetY = 0;

        const boardEl = document.getElementById('game-board');
        const scoreEl = document.getElementById('score');
        const goldEl = document.getElementById('gold');
        const messageEl = document.getElementById('message');

        function saveGold() {
            localStorage.setItem('candySwap_gold', gold);
        }

        function calculateLayout() {
            const rect = boardEl.getBoundingClientRect();
            cellSize = rect.width / 8;
            const topUiSpace = document.getElementById('ui-layer').offsetHeight;
            const availableHeight = rect.height - topUiSpace - 20;
            rows = Math.max(6, Math.floor(availableHeight / cellSize));
            offsetX = (rect.width - (8 * cellSize)) / 2;
            offsetY = topUiSpace + (availableHeight - (rows * cellSize)) / 2;

            for (let r = 0; r < rows; r++) {
                if (!board[r]) continue;
                for (let c = 0; c < 8; c++) {
                    const block = board[r][c];
                    if (block && block.el) {
                        block.el.style.width = `${cellSize}px`;
                        block.el.style.height = `${cellSize}px`;
                        block.el.style.left = `${c * cellSize + offsetX}px`;
                        block.el.style.top = `${r * cellSize + offsetY}px`;
                    }
                }
            }
        }

        function initGame(isRestart = false) {
            // --- NEW: Multiplier logic added here ---
            if (isRestart) { 
                // Default multiplier is 1.0 (no change)
                let multiplier = 1.0; 
                
                // If a theme is loaded and has a multiplier, use it
                if (window.IslandTheme && window.IslandTheme.scoreMultiplier) {
                    multiplier = window.IslandTheme.scoreMultiplier;
                }
                
                // Calculate earned gold with the multiplier
                let earnedGold = Math.floor(score * multiplier);
                gold += earnedGold; 
                
                saveGold(); 
            }
            // --- End of multiplier logic ---

            goldEl.innerText = gold;
            boardEl.innerHTML = '';
            board = []; score = 0; bombActive = false;
            scoreEl.innerText = score;
            isAnimating = false;
            calculateLayout();

            for (let r = 0; r < rows; r++) {
                board[r] = [];
                for (let c = 0; c < 8; c++) {
                    let type;
                    do {
                        type = blockTypes[Math.floor(Math.random() * blockTypes.length)];
                    } while (
                        (c >= 2 && board[r][c-1].type.id === type.id && board[r][c-2].type.id === type.id) ||
                        (r >= 2 && board[r-1][c].type.id === type.id && board[r-2][c].type.id === type.id)
                    );
                    createBlock(r, c, type);
                }
            }
        }

        function createBlock(r, c, type, dropOffset = 0) {
            const el = document.createElement('div');
            el.className = 'block';
            if (type.isBomb) { el.classList.add('bomb'); bombActive = true; }
            const imageUrl = type.isBomb ? BOMB_TYPE.img : type.img;
            el.style.backgroundImage = `url(${imageUrl})`;
            el.style.width = `${cellSize}px`; el.style.height = `${cellSize}px`;
            el.style.left = `${c * cellSize + offsetX}px`;
            el.style.top = `${(r - dropOffset) * cellSize + offsetY}px`;
            boardEl.appendChild(el);
            if (window.IslandTheme && window.IslandTheme.blockBorderColor) {
                el.style.borderColor = window.IslandTheme.blockBorderColor;
            }
            board[r][c] = { r, c, type, el };
            if (dropOffset > 0) setTimeout(() => { el.style.top = `${r * cellSize + offsetY}px`; }, 10);
        }

        let dragStart = null;
        boardEl.addEventListener('pointerdown', e => {
            if (window.MenuSystem && typeof window.MenuSystem.tryStartBGM === 'function') window.MenuSystem.tryStartBGM();
            if (isAnimating || isPaused) return;
            const rect = boardEl.getBoundingClientRect();
            const c = Math.floor((e.clientX - rect.left - offsetX) / cellSize);
            const r = Math.floor((e.clientY - rect.top - offsetY) / cellSize);
            if (r >= 0 && r < rows && c >= 0 && c < 8) {
                dragStart = { r, c, x: e.clientX, y: e.clientY };
                board[r][c].el.classList.add('selected');
            }
        });

        window.addEventListener('pointermove', e => {
            if (!dragStart || isAnimating || isPaused) return;
            const dx = e.clientX - dragStart.x, dy = e.clientY - dragStart.y;
            const dist = cellSize * 0.3;
            if (Math.abs(dx) > dist || Math.abs(dy) > dist) {
                let r2 = dragStart.r, c2 = dragStart.c;
                if (Math.abs(dx) > Math.abs(dy)) c2 += dx > 0 ? 1 : -1;
                else r2 += dy > 0 ? 1 : -1;
                board[dragStart.r][dragStart.c].el.classList.remove('selected');
                if (r2 >= 0 && r2 < rows && c2 >= 0 && c2 < 8) {
                    if (window.playSound) window.playSound('move');
                    swapBlocks(dragStart.r, dragStart.c, r2, c2);
                }
                dragStart = null;
            }
        });

        window.addEventListener('pointerup', () => { if (dragStart) board[dragStart.r][dragStart.c].el.classList.remove('selected'); dragStart = null; });

        async function swapBlocks(r1, c1, r2, c2) {
            isAnimating = true;
            const b1 = board[r1][c1], b2 = board[r2][c2];
            b1.el.style.left = `${c2 * cellSize + offsetX}px`; b1.el.style.top = `${r2 * cellSize + offsetY}px`;
            b2.el.style.left = `${c1 * cellSize + offsetX}px`; b2.el.style.top = `${r1 * cellSize + offsetY}px`;
            board[r1][c1] = b2; board[r2][c2] = b1;
            b1.r = r2; b1.c = c2; b2.r = r1; b2.c = c1;
            await new Promise(r => setTimeout(r, 300));
            const matches = findMatches();
            const bombInvolved = (b1.type.isBomb || b2.type.isBomb);
            if (matches.length > 0 || bombInvolved) handleMatches(matches, 1, bombInvolved ? [b1.type.isBomb ? b1 : b2] : []);
            else {
                b1.el.style.left = `${c1 * cellSize + offsetX}px`; b1.el.style.top = `${r1 * cellSize + offsetY}px`;
                b2.el.style.left = `${c2 * cellSize + offsetX}px`; b2.el.style.top = `${r2 * cellSize + offsetY}px`;
                board[r1][c1] = b1; board[r2][c2] = b2;
                b1.r = r1; b1.c = c1; b2.r = r2; b2.c = c2;
                isAnimating = false;
            }
        }

        function findMatches() {
            const matched = new Set();
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < 6; c++) {
                    const id = board[r][c].type.id;
                    if (id !== 'Bomb' && board[r][c+1].type.id === id && board[r][c+2].type.id === id) { matched.add(`${r},${c}`); matched.add(`${r},${c+1}`); matched.add(`${r},${c+2}`); }
                }
            }
            for (let c = 0; c < 8; c++) {
                for (let r = 0; r < rows - 2; r++) {
                    const id = board[r][c].type.id;
                    if (id !== 'Bomb' && board[r+1][c].type.id === id && board[r+2][c].type.id === id) { matched.add(`${r},${c}`); matched.add(`${r+1},${c}`); matched.add(`${r+2},${c}`); }
                }
            }
            return Array.from(matched).map(s => s.split(',').map(Number));
        }

        async function handleMatches(matches, combo = 1, triggeredBombs = []) {
            if (window.playSound) window.playSound(triggeredBombs.length > 0 ? 'bomb' : 'combo');
            if (triggeredBombs.length > 0) {
                bombActive = false; 
                triggeredBombs.forEach(bomb => {
                    for(let dr = -1; dr <= 1; dr++) {
                        for(let dc = -1; dc <= 1; dc++) {
                            let nr = bomb.r + dr, nc = bomb.c + dc;
                            if (nr >= 0 && nr < rows && nc >= 0 && nc < 8) if (!matches.some(m => m[0] === nr && m[1] === nc)) matches.push([nr, nc]);
                        }
                    }
                });
            }
            score += matches.length * 10 * combo; scoreEl.innerText = score;
            if (combo > 1) { messageEl.innerText = `${combo}X COMBO!`; messageEl.classList.remove('animate'); void messageEl.offsetWidth; messageEl.classList.add('animate'); }
            matches.forEach(([r, c]) => board[r][c]?.el.classList.add('pop'));
            await new Promise(r => setTimeout(r, 300));
            matches.forEach(([r, c]) => { if(board[r][c]) { board[r][c].el.remove(); board[r][c] = null; } });
            for (let c = 0; c < 8; c++) {
                let holes = 0;
                for (let r = rows - 1; r >= 0; r--) {
                    if (board[r][c] === null) holes++;
                    else if (holes > 0) {
                        const b = board[r][c]; board[r + holes][c] = b; board[r][c] = null;
                        b.r = r + holes; b.el.style.top = `${b.r * cellSize + offsetY}px`;
                    }
                }
                for (let h = 0; h < holes; h++) {
                    const isBombSpawn = !bombActive && Math.random() < 0.05;
                    const type = isBombSpawn ? BOMB_TYPE : blockTypes[Math.floor(Math.random() * blockTypes.length)];
                    createBlock(holes - 1 - h, c, type, holes);
                }
            }
            await new Promise(r => setTimeout(r, 400));
            const nextMatches = findMatches();
            if (nextMatches.length > 0) handleMatches(nextMatches, combo + 1);
            else isAnimating = false;
        }

        window.addEventListener('resize', calculateLayout);
        window.onload = async () => { 
            await loadIslandTheme();
            initGame(); 
        };
    </script>
</body>
</html>